{"id":1059494029,"lang":"cpp","lang_name":"C++","time":"2 days, 4 hours","timestamp":1695716766,"status":10,"status_display":"Accepted","runtime":"2626 ms","url":"/submissions/detail/1059494029/","is_pending":"Not Pending","title":"LFU Cache","memory":"179 MB","code":"struct Node {\n    int key;\n    int val;\n    int counter;\n    Node *next;\n    Node *prev;\n    Node(int _key, int _val) {\n        key = _key;\n        val = _val;\n        counter = 1;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\n\nclass LFUCache {\n    Node* head = new Node(-1, -1);\n    Node* tail = new Node(-1, -1);\n    unordered_map<int, Node*> m;\n    int size = 0;\npublic:\n    LFUCache(int capacity) {\n        size = capacity;\n        head->next = tail;\n        tail->next = head;\n    }\n    int get(int key) {\n        unordered_map<int,Node*>::iterator found = m.find(key);\n        // didn't found it\n        updateCounter();\n        if (found == m.end()) {\n            return -1;\n        }\n\n        Node *node = m[key];\n        deleteNode(node);\n        addNode(node);\n        node->counter++;\n        return node->val;\n    }\n    void deleteNode(Node *node) {\n        unordered_map<int, Node*>::iterator found = m.find(node->key);\n        if (found != m.end()) {\n            m.erase(found);\n        }\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n    void addNode(Node* node) {\n        m.insert(make_pair(node->key, node));\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n        node->prev = head;\n    }\n    Node* nextVictim() {\n        Node* t = tail->prev;\n        Node* vic = t;\n        while (t != head) {\n            if (t->counter < vic->counter) {\n                vic = t;\n            }\n            t = t->prev;\n        }\n        cout << \"next vic: \" << vic->key << \", \"  << vic->val << \", \" << vic->counter << endl;\n        return vic;\n    }\n    void updateCounter() {\n        // for (auto &i : m) {\n        //     (i.second)->counter--;\n        // }\n    }\n    void put(int key, int value) {\n        unordered_map<int,struct Node*>::iterator found = m.find(key);\n        // found it\n        if (found != m.end()) {\n            Node *node = m[key];\n            deleteNode(node);\n            addNode(node);\n            node->val = value;\n            node->counter++;\n            updateCounter();\n            return;\n        }\n        if (m.size() == size) {\n            Node *vic = nextVictim();\n            deleteNode(vic);\n        }\n        addNode(new Node(key, value));\n        updateCounter();\n    }\n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */","compare_result":"1111111111111111111111111","title_slug":"lfu-cache","has_notes":false,"flag_type":1}